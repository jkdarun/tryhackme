OWASP TOP 10

SQL injection and command injection
input is passed to SQL queries or system commands
can be prevented using allow list(compared to a list to see if safe or not) and stripping input (dangerous charecters removed)

passthru() in php 
it executes what gets entered into the input then passing the output directly back to the browser.


cut -d : -f 1 /etc/passwd
to get the users from the /etc/passwd file

w    (or)  who
to list currently logged in users

users
to display the users

lastlog
recent login info

lsb_release -a
to check ubuntu version

MOTD - message of the day (used to send a common message to all the users) (welcome message)
/etc/motd is not a script but a text file. contents are shown before the first prompt of a login session.
locate motd
cat  /etc/update-motd.d/00-header

Create a file in /etc/profile.d called greeting.sh
If you don't want to do this for every user, add it to ~/.profile or ~/.bash_profile


Broken authentication
A user would enter login credentials, the server would verify them. If they are correct, the server would then provide the usersâ€™ browser with a session cookie. 
A session cookie is needed because web servers use HTTP(S) to communicate which is stateless. Attaching session cookies means that the server will know who is sending what data. The server can then keep track of users' actions. 

re-registration of an existing user.
say there is an existing user with the name admin and now we want to get access to their account so what we can do is try to re-register that username but with slight modification. We are going to enter " admin"(notice the space in the starting). Now when you enter that in the username field and enter other required information like email id or password and submit that data. It will actually register a new user but that user will have the same right as normal admin. That new user will also be able to see all the content presented under the user admin.


Sensitive Data Exposure
Databases can also be stored as files. These databases are referred to as "flat-file" databases, as they are stored as a single file on the computer.
The most common (and simplest) format of flat-file database is an sqlite database. Can be interacted with sqlite3 client.

file example.db      (shows details about the file)
sqlite3 example.db
sqlite> .tables          (to see the tables in the DB)
sqlite> PRAGMA table_info(customers);             (to see the table information)
sqlite> SELECT * FROM customers;

Password hash cracking
online tool: Crackstation     (to crack weak password hashes like MD5)
Crackstation works using a massive wordlist. If the password is not in the wordlist then Crackstation will not be able to break the hash.


Challenge:
given a webapp's address. developer has left a note indicating that there is sensitive data in a specific directory. Hint: view source code of login page
Found that '/assets' was the directory.
went to 'website_link/assets'
found webapp.db, downloaded it and opened it using sqlite3 after seeing the file type.
sqlite> .tables          (to see the tables in the DB)
sqlite> PRAGMA table_info(useres);             (to see the table information)
sqlite> SELECT * FROM users;
found admin's hashed password. cracked it using crackstation. logged in as admin and found the flag


XML External Entity 
An XML External Entity (XXE) attack is a vulnerability that abuses features of XML parsers/data. It often allows an attacker to interact with any backend or external systems that the application itself can access and can allow the attacker to read the file on that system. They can also cause Denial of Service (DoS) attack or could use XXE to perform Server-Side Request Forgery (SSRF) inducing the web application to make requests to other applications. XXE may even enable port scanning and lead to remote code execution.
There are two types of XXE attacks: in-band and out-of-band (OOB-XXE).
1) An in-band XXE attack is the one in which the attacker can receive an immediate response to the XXE payload.
2) out-of-band XXE attacks (also called blind XXE), there is no immediate response from the web application and attacker has to reflect the output of their XXE payload to some other file or their own server.

XML
defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. It is a markup language used for storing and transporting data. 
XML allows validation using DTD and Schema. This validation ensures that the XML document is free from any syntax error.
 
Syntax
Every XML document mostly starts with what is known as XML Prolog (specifies version and encoding)  (not compulsory, but a good practice)
<?xml version="1.0" encoding="UTF-8"?>

Every XML document must contain a `ROOT` element. For example:

<?xml version="1.0" encoding="UTF-8"?>
<mail>
   <to>falcon</to>
   <from>feast</from>
   <subject>About XXE</subject>
   <text>Teach about XXE</text>
</mail>

<mail> is the ROOT element of that document and <to>, <from>, <subject>, <text> are the children elements. If the XML document doesn't have any root element then it would be consideredwrong or invalid XML doc.

<text category = "message">You need to learn about XXE</text>
category is the attribute name and message is the attribute value.

DTD stands for Document Type Definition. A DTD defines the structure and the legal elements and attributes of an XML document.
example a file named note.dtd with the following content:
<!DOCTYPE note [ <!ELEMENT note (to,from,heading,body)> <!ELEMENT to (#PCDATA)> <!ELEMENT from (#PCDATA)> <!ELEMENT heading (#PCDATA)> <!ELEMENT body (#PCDATA)> ]>

!DOCTYPE note -  Defines a root element of the document named note
!ELEMENT note - Defines that the note element must contain the elements: "to, from, heading, body"
!ELEMENT to - Defines the to element to be of type "#PCDATA"
!ELEMENT from - Defines the from element to be of type "#PCDATA"
!ELEMENT heading  - Defines the heading element to be of type "#PCDATA"
!ELEMENT body - Defines the body element to be of type "#PCDATA"

NOTE: #PCDATA means parseable character data.
!element to define a new element
!doctype to define a ROOT element
!entity to define a new entity

XXE payload and see how they are working:
1) The first payload we'll see is very simple. If you've read the previous task properly then you'll understand this payload very easily.
<!DOCTYPE replace [<!ENTITY name "feast"> ]>
 <userInfo>
  <firstName>falcon</firstName>
  <lastName>&name;</lastName>
 </userInfo>

As we can see we are defining a ENTITY called name and assigning it a value feast. Later we are using that ENTITY in our code.
2) We can also use XXE to read some file from the system by defining an ENTITY and having it use the SYSTEM keyword
<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY read SYSTEM 'file:///etc/passwd'>]>
<root>&read;</root>

Here again, we are defining an ENTITY with the name read but the difference is that we are setting it value to `SYSTEM` and path of the file.
If we use this payload then a website vulnerable to XXE(normally) would display the content of the file /etc/passwd.

https://hackingprofessional.github.io/Security/How-to-hack-a-website-with-XML-External-Entity-Injection/



Broken Access Control
broken access control allows attackers to bypass authorization which can allow them to view sensitive data or perform tasks as if they were a privileged user.
sccenario: change parameters in SQL call, force browses to target URLs

IDOR, or Insecure Direct Object Reference, is the act of exploiting a misconfiguration in the way user input is handled, to access resources you wouldn't ordinarily be able to access. IDOR is a type of access control vulnerability.


Security Misconfiguration 
occur when security could have been configured properly but was not.
Security misconfigurations include:

Poorly configured permissions on cloud services, like S3 buckets
Having unnecessary features enabled, like services, pages, accounts or privileges
Default accounts with unchanged passwords
Error messages that are overly detailed and allow an attacker to find out more about the system
Not using HTTP security headers, or revealing too much detail in the Server: HTTP header

find default credentials by searching for "pensive notes default credentials " on google. open the first github link to find the username and password
